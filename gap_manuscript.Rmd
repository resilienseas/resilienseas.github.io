---
title: "manuscript_gap_analysis"
author: "Rae"
date: "12/16/2018"
---
title: "manuscript_gap_analysis"
author: "Rae"
date: "12/16/2018"
output:
  html_document:
    df_print: paged
  pdf_document: 
  word_document: default
---

```{r setup, include=TRUE, cache = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup
Load packages, set cache, define study area

```{r packages / cache}
if (!require(pacman)) install.packages("pacman")
library(pacman)
p_load(
  tidyverse, here, glue,
  raster,
  sdmpredictors, dismo, 
  deldir, 
  mapview,
  tmap,
  ggplot2,
  rgdal,
  gstat,
  usdm,
  knitr,
  tmap)
# custom R package: oatools
#devtools::load_all(here("../oatools")) # for developing

#library(oatools) # devtools::install_github("resilinseas/oatools") # for eventual production
# paths & variables ----
dir_data        <- here("data")
dir_sdmdata_old <- here("data/sdmpredictors")
dir_cache       <- here("cache")
dir_sdmdata     <- here("cache/sdmpredictors")
SST_tif <- here("data/sst_mean.tif")
DO_tif  <- here("data/do_mean.tif")

# reorganize dirs so "cache" is always local and ignored by git, vs all in "data" tracked by git & pushed to github
if (!dir.exists(dir_data))    dir.create(dir_data)
if (!dir.exists(dir_cache))   dir.create(dir_cache)
if (!dir.exists(dir_sdmdata) & dir.exists(dir_sdmdata_old))
  file.rename(dir_sdmdata_old, dir_sdmdata)
if (!dir.exists(dir_sdmdata)) dir.create(dir_sdmdata)
 list<- list_layers("Bio-ORACLE")

# extent of NE Pacific study area, for cropping rasters
ext_study <- extent(-670000, 340000, -600000, 1215000)
ext_study_alin <- extent(-670000, 340000, -600000, 350000)
ext_study_juranek <- extent(-670000, 340000, 150000, 1215000)
crs_study <- '+init=EPSG:6414'

# sea surface temperature
# devtools::load_all(here("../oatools")) # for use while developing
r_sst_min <- lyr_to_tif(
  lyr = "BO_sstmin", 
  tif = here("data/sst_min.tif"),
  crs = crs_study,
  dir_sdm_cache = dir_sdmdata,
  extent_crop   = ext_study, 
  redo=T, fill_na=TRUE, fill_window=11)

r_sst_min_alin <- crop(r_sst_min, ext_study_alin)
r_sst_min_juranek <- crop(r_sst_min, ext_study_juranek)

n_na_nofill <- sum(is.na(raster::getValues(r_sst_min_nofill)))
n_na        <- sum(is.na(raster::getValues(r_sst_min)))
```

## Create SST/DO min/max rasters from bio-oracle data
Min is used here to determine a worst case scenario for aragonite saturation state, and max is used with min to determine aragonite saturation state range

```{r bio-Oracle}
#sst max
r_sst_max <- lyr_to_tif(
  lyr = "BO_sstmax", 
  tif = here("data/sst_min.tif"),
  crs = crs_study,
  dir_sdm_cache = dir_sdmdata,
  extent_crop   = ext_study, 
  redo=T, fill_na=TRUE, fill_window=11)
r_sst_max_alin <- crop(r_sst_max, ext_study_alin)
r_sst_max_juranek <- crop(r_sst_max, ext_study_juranek)

#do min
r_do_min <- lyr_to_tif(
  lyr = "BO2_dissoxmin_bdmin", 
  tif = here("data/do_min.tif"),
  crs = crs_study,
  dir_sdm_cache = dir_sdmdata,
  extent_crop   = ext_study, 
  redo=T, fill_na=TRUE, fill_window=11)
r_do_min_alin <- crop(r_do_min, ext_study_alin)
r_do_min_juranek <- crop(r_do_min, ext_study_juranek)

r_do_max <- lyr_to_tif(
  lyr = "BO2_dissoxmax_bdmin", 
  tif = here("data/do_max.tif"),
  crs = crs_study,
  dir_sdm_cache = dir_sdmdata,
  extent_crop   = ext_study, 
  redo=T, fill_na=TRUE, fill_window=11)
r_do_max_alin <- crop(r_do_max, ext_study_alin)
r_do_max_juranek <- crop(r_do_max, ext_study_juranek)

```

## Use Juranek 2009 model to create ocean acidification layer for the study region

```{r Juranek model}
#juranek aragonite
j0 = 9.242*10^-1
j1 = 4.492*10^-3
j2 = 9.40 * 10^-4
jo2r = 140
jtr = 8
juranek_arag <- j0 + j1 * (r_do_min_juranek-jo2r) + j2 * (r_do_min_juranek-jo2r) * (r_sst_min_juranek-jtr)
```

##Repeat using Alin 2012 model

```{r Alin model}
#alin aragonite
a0 = 1.112
a1 = 9.59*10^-2
a2 = 3.54*10^-3
a3 = 5.91*10^-4
ao2r = 138.46
atr = 10.28

alin_arag <- a0 + a1 * (r_sst_min_alin-atr) + a2 * (r_do_min_alin-ao2r) + a3 * (r_sst_min_alin-atr) * (r_do_min_alin-ao2r)
```

## Combine model outputs
Here we see a zonal difference between the models, and a bit of a latitudinal difference, especially in the California Bight region
```{r model comparison}
arag <- mosaic(alin_mosaic, juranek_mosaic, fun = mean)
```

## Create variograms for each of the models
```{r variogram, eval = TRUE}
aragdf <- as.data.frame(arag, xy = TRUE)
aragdf <- aragdf %>% #remove N/A values
  mutate(layer=replace(layer, layer==-999.000, NA)) %>%
  na.omit(aragdf)
coordinates(aragdf)<-  ~ x + y #transform into spatial points
aragvar <- variogram(layer~1, aragdf)
```

##Loess for Alin Variogram
```{r loess}
lo <- loess(aragvar$dist ~ aragvar$gamma, aragvar)
```

##Prep Inventory
These are the same steps from our GP paper, which we use to create an OA layer in which all the cells in our study site are assigned the aragonite saturation state measured at the nearest monitoring point. 
```{r prep inventory, results = "hide"}
# import inventory
inventory <- read_csv(here("data/inventory.csv"))
#remove non OAH focus entries
oahfocus <- subset(inventory, OAHFocus == "OA" | OAHFocus == "H" | OAHFocus == "OAH")
#quantify frequencies
unique(oahfocus$MeasFreq)
oahfocus$MeasFreq[oahfocus$MeasFreq =="Once"] <- 0
oahfocus$MeasFreq[oahfocus$MeasFreq == 10] <- 52560
oahfocus$MeasFreq[oahfocus$MeasFreq =="< 6 hours"] <- 1460
oahfocus$MeasFreq[oahfocus$MeasFreq == 60] <- 8760
oahfocus$MeasFreq[oahfocus$MeasFreq =="Daily"] <- 365
oahfocus$MeasFreq[oahfocus$MeasFreq ==30] <- 17520
oahfocus$MeasFreq[oahfocus$MeasFreq == 20] <- 26280
oahfocus$MeasFreq[oahfocus$MeasFreq == 15] <- 35040
oahfocus$MeasFreq[oahfocus$MeasFreq =="Quarterly"] <- 4
oahfocus$MeasFreq[oahfocus$MeasFreq =="Annual"] <- 1
oahfocus$MeasFreq[oahfocus$MeasFreq =="Monthly"] <- 12
oahfocus$MeasFreq[oahfocus$MeasFreq == 5] <- 105120
oahfocus$MeasFreq[oahfocus$MeasFreq == 6] <- 87600
oahfocus$MeasFreq[oahfocus$MeasFreq =="Semi-annual"] <- 2
oahfocus$MeasFreq[oahfocus$MeasFreq == 180] <- 2920
oahfocus$MeasFreq[oahfocus$MeasFreq == 2] <- 262800
oahfocus$MeasFreq[oahfocus$MeasFreq == 0.25] <- 2102400
oahfocus$MeasFreq[oahfocus$MeasFreq == 3] <- 175200
oahfocus$MeasFreq[oahfocus$MeasFreq == 1] <- 525600
oahfocus$MeasFreq[oahfocus$MeasFreq == 120] <- 2920
oahfocus$MeasFreq[oahfocus$MeasFreq =="Bi-weekly"] <- 26
oahfocus$MeasFreq[oahfocus$MeasFreq == 360] <- 1460
oahfocus$MeasFreq[oahfocus$MeasFreq == 720] <- 730
oahfocus$MeasFreq[oahfocus$MeasFreq =="Seasonally"] <- 1
oahfocus$MeasFreq[oahfocus$MeasFreq =="1/4 second"] <- 126144000
oahfocus$MeasFreq[oahfocus$MeasFreq =="Bi-monthly"] <- 6
oahfocus$MeasFreq[oahfocus$MeasFreq =="5  Years"] <- 0.2
oahfocus$MeasFreq[oahfocus$MeasFreq =="Bi-weekly"] <- 26
oahfocus$MeasFreq[oahfocus$MeasFreq =="Variable"] <- 0
oahfocus$MeasFreq[oahfocus$MeasFreq =="Decadal"] <- 0.1
oahfocus$MeasFreq[oahfocus$MeasFreq =="Biennial"] <- 0.5
oahfocus$MeasFreq[oahfocus$MeasFreq =="Weekly"] <- 52
oahfocus$MeasFreq[oahfocus$MeasFreq =="Triennial"] <- 0.33333
oahfocus$MeasFreq[oahfocus$MeasFreq =="Trimester"] <- 3
unique(oahfocus$MeasFreq)
#remove NA coordinates
oahfocus <- oahfocus[!is.na(oahfocus$Latitude), ]
oahfocus <- oahfocus[!is.na(oahfocus$Longitude), ]
#remove spaces and transform to numeric
gsub(" ", "", oahfocus$Latitude)
gsub(" ", "", oahfocus$Longitude)
gsub("'<ca>'", "", oahfocus$Longitude)
oahfocus$Longitude<-as.numeric(oahfocus$Longitude)
oahfocus$Latitude<-as.numeric(oahfocus$Latitude)
#subsets
carbcomplete<-subset(oahfocus, DisCrbPmtr>1 | ISCrbPmtr > 1)
incomplete <- subset(oahfocus, DisCrbPmtr<2 & ISCrbPmtr < 2 & AssetType == "Mooring" | AssetType == "Shoreside Sensor" | AssetType == "Samplesite" | AssetType == "Shoreside sensor" | AssetType == NA)
highfrequency<-subset(oahfocus, MeasFreq > 364)
highfreqcarbcomplete<-subset(oahfocus, MeasFreq > 364 & DisCrbPmtr>1 | MeasFreq > 364 & ISCrbPmtr > 1)
lowfrequency <- subset(oahfocus, MeasFreq < 365 & AssetType == "Mooring" | AssetType == "Shoreside Sensor" | AssetType == "Samplesite" | AssetType == "Shoreside sensor" | AssetType == NA)
# isolate coordinate columns
coords <- cbind.data.frame(oahfocus$Longitude, oahfocus$Latitude)
carbcompletecoords <- cbind.data.frame(carbcomplete$Longitude, carbcomplete$Latitude)
incompletecoords <- cbind.data.frame(incomplete$Longitude, incomplete$Latitude)
highfrequencycoords <- cbind.data.frame(highfrequency$Longitude, highfrequency$Latitude)
lowfrequencycoords <- cbind.data.frame(lowfrequency$Longitude, lowfrequency$Latitude)
highfreqcarbcompletecoords <- cbind.data.frame(highfreqcarbcomplete$Longitude, highfreqcarbcomplete$Latitude)
# remove duplicate locations
deduped.coords<-unique(coords)
deduped.carbcomplete <- unique(carbcompletecoords)
deduped.incomplete <- unique(incompletecoords)
deduped.highfrequency <- unique(highfrequencycoords)
deduped.lowfrequency <- unique(lowfrequencycoords)
deduped.highfreqcarbcomplete <- unique(highfreqcarbcompletecoords)
# create spatial points objects
inventorycoords <- SpatialPoints(deduped.coords, CRS("+proj=longlat +ellps=WGS84"))
inventorycoords <- spTransform(inventorycoords, CRS('+init=EPSG:6414'))
carbcompletecoords <- SpatialPoints(deduped.carbcomplete, CRS("+proj=longlat +ellps=WGS84"))
carbcompletecoords <- spTransform(carbcompletecoords, CRS('+init=EPSG:6414'))
incompletecoords <- SpatialPoints(deduped.incomplete, CRS("+proj=longlat +ellps=WGS84"))
incompletecoords <- spTransform(incompletecoords, CRS('+init=EPSG:6414'))
highfreqcoords <- SpatialPoints(deduped.highfrequency, CRS("+proj=longlat +ellps=WGS84"))
highfreqcoords <- spTransform(highfreqcoords, CRS('+init=EPSG:6414'))
lowfreqcoords <- SpatialPoints(deduped.lowfrequency, CRS("+proj=longlat +ellps=WGS84"))
lowfreqcoords <- spTransform(lowfreqcoords, CRS('+init=EPSG:6414'))
highfreqcarbcompletecoords <- SpatialPoints(deduped.highfreqcarbcomplete, CRS("+proj=longlat +ellps=WGS84"))
highfreqcarbcompletecoords <- spTransform(highfreqcarbcompletecoords, CRS('+init=EPSG:6414'))
# check to make sure projections match
# devtools::load_all(here("../oatools")) # for use while developing
# create voronoi polygons
vor <-voronoi(inventorycoords)
carbcompletevor <- voronoi(carbcompletecoords)
incompletevor <- voronoi(incompletecoords)
highfreqvor <- voronoi(highfreqcoords)
lowfreqvor <- voronoi(lowfreqcoords)
# rasterize polygons
vorraster<- rasterize(vor, r_sst_min, "id")
carbcompletevorraster<- rasterize(carbcompletevor, r_sst_min, "id")
incompletevorraster<- rasterize(incompletevor, r_sst_min, "id")
highfreqvorraster<- rasterize(highfreqvor, r_sst_min, "id")
lowfreqvorraster<- rasterize(lowfreqvor, r_sst_min, "id")
```

##Create OA layer
Here we assign each cell the aragonite value from the nearest monitoring site
```{r polygons}
#extract aragonite saturation state value for each monitoring site
sitearag<- raster::extract(arag, inventorycoords, method='simple', df=TRUE)
carbcompletesitearag<- raster::extract(arag, carbcompletecoords, method='simple', df=TRUE)
highfreqsitearag<- raster::extract(arag, highfreqcoords, method='simple', df=TRUE)
# rename column names of sitesstrange
colnames(sitearag)<-c("id", "Arag")
colnames(carbcompletesitearag)<-c("id", "Arag")
colnames(highfreqsitearag)<-c("id", "Arag")
# substitute polygon id for monitoring site sea surface temerature of that polygon
polygonarag<-subs(vorraster, sitearag, by="id", which="Arag", subsWithNA=FALSE)
carbcompletepolygonarag <- subs(carbcompletevorraster, carbcompletesitearag, by="id", which="Arag", subsWithNA=FALSE)
highfreqpolygonarag <- subs(highfreqvorraster, highfreqsitearag, by="id", which="Arag", subsWithNA=FALSE)
```

## Determine semivariance

```{r semivariance}
#vij = (xi-xj)^2/2

vij<- (arag-polygonarag)^2/2
carbcompletevij <- (arag-carbcompletepolygonarag)^2/2
highfreqvij <- (arag-highfreqpolygonarag)^2/2
```

## Find Oceanographic distance
This is done as an alternative to predict/uniroot since I hit a roadblock there. I chose the Alin variogram, and created a linear model that describes the relationship between distance and semivariance, and applied it to the semivariance rasters

```{r oceanographic distance}
aragmodel <- lm(var$dist ~ var$gamma, data = var)
intercept <- coef(model)[1]
slope <- coef(model)[2]
oceanographicdistance = slope * vij + intercept
carbcompleteoceanographicdistance = slope * carbcompletevij + intercept
highfreqoceanographicdistance = slope * highfreqvij + intercept
ggplot()+
  geom_point(aes(mosaicvar$dist, mosaicvar$gamma))+
  stat_smooth(aes(mosaicvar$dist, mosaicvar$gamma), method = lm)+
  theme_bw()+
  ggtitle('Semivarioram of Aragonite Discrepancy and Distance')+
  xlab('Distance Between Points (m)')+
  ylab('Semivariance of Aragonite Discrepancy')
  
```

## Geographic distance
Determine geographic distance from the nearest monitoring point
```{r geographic distance}
distance<-distanceFromPoints(oceanographicdistance, inventorycoords)
carbcompletedistance<-distanceFromPoints(carbcompleteoceanographicdistance, carbcompletecoords)
highfreqdistance<-distanceFromPoints(highfreqoceanographicdistance, highfreqcoords)
```

## Temporal Variation
This step determines the range in aragonite saturation state across the region by using max values of T and DO to find the max aragonite saturation state, and min values to find the min aragonite saturation state. The difference is the range. I also normalized this step. One problem I have here is that due to the coefficients (atr and ao2r) there are some places in the study region where using the max values of do and sst gives you are smaller value for aragonite saturation state than the min values do. This is because when you use the max values, for some raster cells the a3 term has a positive component and a negative component leading to a negative sign on the a3 term, whereas when you use the min values those raster cells have two negative components, leading to a positive sign on the a3 term. So I used the abs value of the range, but I'm not sure this makes sense, and maybe there is a better way to find the range. Using the range rasters for SST/DO is a possibility, but that method yields a really different result. 

```{r temporal variation}

alinaragrange <- a1 * (r_sst_range_alin) + a2 * (r_do_range_alin) + a3 * (r_sst_min*r_do_min + r_sst_range*r_do_min + r_sst_min*r_do_range +r_sst_range*r_do_range)

juranekaragrange <- j1 * (r_do_range_juranek) + j2 * (r_sst_min*r_do_min + r_sst_range*r_do_min + r_sst_min*r_do_range +r_sst_range*r_do_range)

aragrange <- mosaic(alinaragrange, juranekaragrange, fun = mean)

aragrange <- aragrange/maxValue(aragrange)

```

## Find Gaps
Here I used the euclidean distance to combine the oceanographic distance and the geographic distance. I used a weighting factor of on the oceanographic distance, which is the max value of distance / max value of oceanographic distance, so that the two parameters combine equally. I multiplied each distance by the range of the aragonite saturation state, such that locations with equal distances will be "gappier" if their aragonite saturation state has a large range. This is to account for temporal variation. 

```{r find gaps}
poly_coast<- readOGR(dsn=path.expand("/Users/raetaylor-burns/downloads/Export_Output_2"), layer="Export_Output_2") #Load coast shapefile using pathway on personal computer

Canada<- readOGR(dsn=path.expand("/Users/raetaylor-burns/downloads/Canada"), layer="Canada") #Load coast shapefile using pathway on personal computer

poly_coast <- spTransform(poly_coast, crs(crs_study)) #Assign same CRS as aragonite layer

Canada <- spTransform(Canada, crs(crs_study)) #Assign same CRS as aragonite layer

weight = maxValue(distance)/maxValue(oceanographicdistance)

gap<-aragrange^2*(setValues(distance, sqrt((getValues(distance)^2+(getValues(mosaic_weight*oceanographicdistance)^2)))))

gapaggregate <- disaggregate(gap, fact=5)

clipped <- mask(gap_aggregate, poly_coast, inverse = TRUE) #Clip continuous raster

clipped <- mask(clipped, Canada, inverse = TRUE) #Clip continuous raster

carbcompletegap<-aragrange^2*setValues(carbcompletedistance, sqrt((getValues(carbcompletedistance)^2+(getValues(weight*carbcompleteoceanographicdistance)^2))))

ccgap_aggregate <- disaggregate(carbcompletegap, fact=5)

ccgap_clipped <- mask(ccgap_aggregate, poly_coast, inverse = TRUE) #Clip continuous raster

ccgap_clipped <- mask(ccgap_clipped, Canada, inverse = TRUE) #Clip continuous raster

highfreqgap<-aragrange^2*setValues(highfreqdistance, sqrt((getValues(highfreqdistance)^2+(getValues(weight*highfreqoceanographicdistance)^2))))

hfgap_aggregate <- disaggregate(highfreqgap, fact=50)

hfgap_clipped <- mask(hfgap_aggregate, poly_coast, inverse = TRUE) #Clip continuous raster

hfgap_clipped <- mask(hfgap_clipped, Canada, inverse = TRUE) #Clip continuous raster
```

## Map Gaps
Visualize gaps using tmap

```{r map gaps}
tmap_mode("plot")
pal <- colorRampPalette(c("royalblue2", "white", "red"))
setwd("/Users/raetaylor-burns/downloads")
gap <- tm_shape(gap_clipped)+
  tm_raster(palette = pal(10), colorNA = NULL, title = "Data Gaps", alpha = 0.8, auto.palette.mapping = FALSE)+
  tm_layout(main.title = "Ocean Acificitation Data Gaps", main.title.size = 1, bg.color = "white", main.title.position = c("center", "top"), legend.show = TRUE, legend.position = c(0.5, 0.4), legend.title.size = 1, fontfamily = "serif", fontface = "bold")+
  tm_layout(basemaps = c('OpenStreetMap'))+
  tmap_options(max.raster = c(plot = 45955000, view = 45955000))
tmap_save(gap, "gaps.png", width = 2000, height = 4000, dpi = 500)
ccgap <- tm_shape(ccgap_clipped)+
  tm_raster(palette = pal(10), colorNA = NULL, title = "Data Gaps", alpha = 0.8, auto.palette.mapping = FALSE)+
  tm_layout(main.title = "Carbonate Complete Data Gaps", main.title.size = 1, bg.color = "white", main.title.position = c("center", "top"), legend.show = TRUE, legend.position = c(0.5, 0.4), legend.title.size = 1, fontfamily = "serif", fontface = "bold")+
  tm_layout(basemaps = c('OpenStreetMap'))+
  tmap_options(max.raster = c(plot = 45955000, view = 45955000))+
  tm_shape(incompletecoords)+
  tm_dots(col = "black", size = 0.01)
tmap_save(ccgap, "ccgaps.png", width = 2000, height = 4000, dpi = 500)
hfgap <- tm_shape(hfgap_clipped)+
  tm_raster(palette = pal(10), colorNA = NULL, title = "Data Gaps", alpha = 0.8, auto.palette.mapping = FALSE)+
  tm_layout(main.title = "High Frequency Data Gaps", main.title.size = 1, bg.color = "white", main.title.position = c("center", "top"), legend.show = TRUE, legend.position = c(0.5, 0.4), legend.title.size = 1, fontfamily = "serif", fontface = "bold")+
  tm_layout(basemaps = c('OpenStreetMap'))+
  tmap_options(max.raster = c(plot = 45955000, view = 45955000))+
  tm_shape(incompletecoords)+
  tm_dots(col = "black", size = 0.01)
tmap_save(hfgap, "hfgaps.png", width = 2000, height = 4000, dpi = 500)
  
output:
  html_document:
    df_print: paged
  pdf_document: 
  word_document: default
---
