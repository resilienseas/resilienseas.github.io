---
title: "Manuscript Gap Analysis"
output: html_document
---

```{r setup, echo = FALSE, results = "hide", include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Introduction

Given the existing monitoring network, our analysis locates the best site for the next monitoring asset, thereby filling in monitoring network gaps one asset at a time, based off the sites that already are in place. In this analysis we utilized methods that fall in the middle of the spectrum defined by other works in this realm (see Asch et al. (2003) for a more simplistic approach, and Frolov et al. 2013 for a more involved approach). These decisions were made due to the constraints of the data we used (spatial metadata as opposed to time series and satellite data) as well as the goal of working with policymakers and non-scientist end users. The result is an analysis that provides specific spatial information on relative sampling of ocean acidification on the West Coast. 
Monitoring networks are geographic objects, and it might seem that the ideal network would evenly spaced across the ocean. However, the ocean is not uniform: some places in the ocean are more dynamic, both spatially and temporally, than others. This effect can be illustrated with an example from the Santa Barbara Channel (see LTER analysis). Thus, where the ocean is highly dynamic, an ideal monitoring network will have more closely clustered assets than in places that are more static.

##Step 1. Manipulate sea surface temperature and dissolved oxygen estimate make aragonite saturation state
#### Setup
Load packages, set cache, define study area
```{r packages / cache}
if (!require(pacman)) install.packages("pacman")
library(pacman)
p_load(
  tidyverse, here, glue,
  raster,
  sdmpredictors, dismo, 
  deldir, 
  mapview,
  tmap,
  ggplot2,
  rgdal,
  gstat,
  usdm,
  knitr,
  tmap,
  rnaturalearth, 
  grid,
  gridExtra)
# custom R package: oatools
devtools::load_all(here("../oatools")) # for developing

#library(oatools) # devtools::install_github("resilinseas/oatools") # for eventual production
# paths & variables ----
dir_data        <- here("data")
dir_sdmdata_old <- here("data/sdmpredictors")
dir_cache       <- here("cache")
dir_sdmdata     <- here("cache/sdmpredictors")
SST_tif <- here("data/sst_mean.tif")
DO_tif  <- here("data/do_mean.tif")

# reorganize dirs so "cache" is always local and ignored by git, vs all in "data" tracked by git & pushed to github
if (!dir.exists(dir_data))    dir.create(dir_data)
if (!dir.exists(dir_cache))   dir.create(dir_cache)
if (!dir.exists(dir_sdmdata) & dir.exists(dir_sdmdata_old))
  file.rename(dir_sdmdata_old, dir_sdmdata)
if (!dir.exists(dir_sdmdata)) dir.create(dir_sdmdata)
 list<- list_layers("Bio-ORACLE")

# extent of NE Pacific study area, for cropping rasters
ext_study <- extent(-500000, 340000, -600000, 1215000)
crs_study <- '+init=EPSG:6414'

ext_study_socal <- extent (-43000, 280000, -600000, -380000)
ext_study_cencal <- extent (-250000, -50000, -390000, -15000)
ext_study_norcal <- extent (-500000, -200000, -20000, 460000)
ext_study_orcoast <- extent(-500000, -200000, 500000, 900000)

ext_study_wacoast <- extent(-500000, -150000, 900000, 1215000)

ext_study_pugetsound <- extent(-300000, -150000, 1000000, 1215000)


# extent of larger area for voronoi polygons
ext_study_vor <- extent(-700000, 340000, -800000, 1305000)
ext_study_alin <- extent(-7000000, 340000, -800000, 470000)
ext_study_juranek <- extent(-7000000, 340000, -100000, 1305000)


# import shapefiles for cropping to coast
poly_coast<- readOGR(dsn=path.expand("/Users/raetaylor-burns/Desktop/RTB/gap_analysis_manuscript/Export_Output_2"), layer="Export_Output_2")
Canada<- readOGR(dsn=path.expand("/Users/raetaylor-burns/Desktop/RTB/gap_analysis_manuscript/Canada"), layer="Canada")
states<- readOGR(dsn=path.expand("/Users/raetaylor-burns/Desktop/RTB/gap_analysis_manuscript/cb_2016_us_state_20m"), layer="cb_2016_us_state_20m")
poly_coast <- spTransform(poly_coast, crs(crs_study))
Canada <- spTransform(Canada, crs(crs_study))
states <- spTransform(states, crs(crs_study))


# sea surface temperature
# devtools::load_all(here("../oatools")) # for use while developing
r_sst_min <- lyr_to_tif(
  lyr = "BO_sstmean", 
  tif = here("data/sst_min.tif"),
  crs = crs_study,
  dir_sdm_cache = dir_sdmdata,
  extent_crop   = ext_study_vor, 
  redo=T, fill_na=TRUE, fill_window=11)

r_sst_min_alin <- crop(r_sst_min, ext_study_alin)-0.2
r_sst_min_juranek <- crop(r_sst_min, ext_study_juranek)-0.2

n_na        <- sum(is.na(raster::getValues(r_sst_min)))
```

####Create SST/DO min/max rasters from bio-oracle data
Aragonite saturation state is the gold standard in an ocean acidification monitoring network, as this measurement has direct biological implications.9 However, the variables needed to calculate aragonite saturation state are not yet measured at a sufficient spatial-temporal resolution to identify highly variable locations across the study region. While this raw data could theoretically be replaced by a high-resolution model that would explicitly account for physical, chemical, and biological oceanographic processes, and integrate a variety of input data, such models are not yet available (although some are under development). In the absence of a model or data to describe aragonite saturation state, we used temperature and dissolved oxygen as proxies, because they are strongly positively correlated with aragonite saturation state.
```{r bio-Oracle}

#from PISCES, units in micromol/m3
#r_do_min <- lyr_to_tif(
#  lyr = "BO2_dissoxmean_ss", 
#  tif = here("data/do_min.tif"),
#  crs = crs_study,
#  dir_sdm_cache = dir_sdmdata,
#  extent_crop   = ext_study_vor, 
#  redo=T, fill_na=TRUE, fill_window=11)
# units to micromol/kg 
#r_do_min <- r_do_min

#r_do_min_alin <- crop(r_do_min, ext_study_alin)
#r_do_min_juranek <- crop(r_do_min, ext_study_juranek)

# from observations, units in ml/l
r_do_min <- lyr_to_tif(
  lyr = "BO_dissox", 
  tif = here("data/do_min.tif"),
  crs = crs_study,
  dir_sdm_cache = dir_sdmdata,
  extent_crop   = ext_study_vor, 
  redo=T, fill_na=TRUE, fill_window=11)
#units to micromol/kg
r_do_min <- r_do_min*(1000/(0.022391*1027))


r_do_min_alin <- crop(r_do_min, ext_study_alin)
r_do_min_juranek <- crop(r_do_min, ext_study_juranek)





```

####Use Juranek 2009 and Alin 2012 model to create ocean acidification layer for the study region
At a sub-regional scale, empirically validated models have been developed that predict aragonite saturation state based on temperature and dissolved oxygen measurements. Our analysis utilized equation II from Alin et al. (2012) in the southern part of the study region and equation 3 from Juranek et al. (2009) in the northern part of the study region. We then created a “worst-case scenario” aragonite saturation state raster using the minimum sea surface temperature and dissolved oxygen values from each ocean area. 
```{r Juranek and Alin models}
#juranek aragonite
j0 = 9.242*10^-1
j1 = 4.492*10^-3
j2 = 9.40 * 10^-4
jo2r = 140
jtr = 8
juranek_arag <- j0 + j1 * (r_do_min_juranek-jo2r) + j2 * (r_do_min_juranek-jo2r) * (r_sst_min_juranek-jtr)

#alin aragonite
a0 = 1.112
a1 = 9.59*10^-2
a2 = 3.54*10^-3
a3 = 5.91*10^-4
ao2r = 138.46
atr = 10.28

alin_arag <- a0 + a1 * (r_sst_min_alin-atr) + a2 * (r_do_min_alin-ao2r) + a3 * (r_sst_min_alin-atr) * (r_do_min_alin-ao2r)





#juranek aragonite
j0 = 9.242*10^-1
j1 = 4.492*10^-3
j2 = 9.40 * 10^-4
jo2r = 140
jtr = 8
juranek_arag <- j0 + j1 * (r_do_min-jo2r) + j2 * (r_do_min-jo2r) * (r_sst_min-jtr)

#alin aragonite
a0 = 1.112
a1 = 9.59*10^-2
a2 = 3.54*10^-3
a3 = 5.91*10^-4
ao2r = 138.46
atr = 10.28

alin_arag <- a0 + a1 * (r_sst_min-atr) + a2 * (r_do_min-ao2r) + a3 * (r_sst_min-atr) * (r_do_min-ao2r)


```

####Combine model outputs
To reduce the effect of the abrupt change in aragonite saturation state at the boundary between the two models, the mean of the two model outputs was used to predict aragonite saturation state in waters between Eureka and Fort Bragg, a distance of about 100 miles.
```{r model comparison}
arag <- mosaic(alin_arag, juranek_arag, fun = mean)
```

####Evaluate aragonite
To evaluate the map of aragonite saturation state we compared values to those taken on the NOAA OA cruise in 2013. 
```{r evaluate aragonite map}

# get coordinates from 2013 NOAA OA Cruise
cruisedata <- read_csv(here("data/WCOAC_2013_test.csv"))
cruisecoords <- cbind.data.frame(cruisedata$Long, cruisedata$Lat)
cruisecoords <- SpatialPoints(cruisecoords, CRS("+proj=longlat +ellps=WGS84"))

# extract aragonite saturation state from empirical models at cruise stations
evalarag<- raster::extract(arag, cruisecoords, method='simple', df=TRUE)

#create dataframe with cruise aragonite, model aragonite and depth
colnames(evalarag) <- c("ID", "modelarag")
evalarag$depth <- cruisedata$`Pressure (db)`
evalarag$cruisearag <- cruisedata$OmegaAr

# remove -999 values and measurements at depth from cruise
evalarag <- subset(evalarag, cruisearag != -999)

#filter for surface observations
evalarag<- evalarag[evalarag[, 3]<5,] 

# filter for low observations due hotspots
# evalarag <- evalarag[evalarag$cruisearag>1.5,]

# plot to compare cruise and model
plot(evalarag$modelarag, evalarag$cruise)

modeleval <- lm(evalarag$cruise ~ evalarag$modelarag)
summary(modeleval)


```


####Create mean of NOAA OA cruises

```{r}

# 2011

aragonite_data <- read_csv(here("data/WCOAC_2011_test.csv")) #load data
colnames(aragonite_data) <- c("Date", "Time", "Lat", "Long", "Pressure", "OmegaAr") #rename columns in dataframe

aragonite_data <- aragonite_data[-c(7)]

aragonite_data <- aragonite_data %>% #remove N/A values
  mutate(OmegaAr=replace(OmegaAr, OmegaAr==-999.000, NA)) %>%
  na.omit(aragonite_data)

aragonite_data<- aragonite_data[aragonite_data[, 5]<5,] #filter for surface observations

coordinates(aragonite_data)<-  ~ Long + Lat #transform into spatial points

zd<-zerodist(aragonite_data)
aragonite_data<-aragonite_data[-zd[,2],] #remove observations taken at same coordinate point

aragonite_var<-variogram(OmegaAr ~1, data=aragonite_data, alpha=c(0, 45, 90, 135))
plot(aragonite_var) #look for anisotropy and create variogram of aragonite values

aragonite_fit<-fit.variogram(aragonite_var,model=vgm(nugget=0.1,psill=0.5,range=4,model="Exp", anis=c(0, 0.3))) #fit a model to the values based on estimated nugget, sill, and range, and anisotropy
plot(aragonite_var,aragonite_fit)


extent <- bbox(aragonite_data) #get extent of cruise observations 
long<-seq(extent[1,1],extent[1,2],length=388) #increase ROI by one degree in each direction
lat<-seq(extent[2,1],extent[2,2],length=1000)


aragonite_grid<-expand.grid(long,lat) #create grid for interpolation surface
colnames(aragonite_grid)<- c("long", "lat")
coordinates(aragonite_grid) <- ~ long + lat
gridded(aragonite_grid)=TRUE

aragonitekrige<-krige(OmegaAr ~ 1, aragonite_data, newdata=aragonite_grid, model=aragonite_fit) #run kriging on interpolation grid, based on best fit model

aragonite_raster<-raster(aragonitekrige, layer=1, values=TRUE) #transform krige object to raster
projection(aragonite_raster) <- CRS("+proj=longlat +datum=WGS84") #set CRS 
aragonite_raster_proj_2011 <- projectRaster(aragonite_raster, crs=CRS('+init=EPSG:6414'),method="ngb") #re-project to California Teale Albers Equal Area

#2012

aragonite_data <- read_csv(here("data/WCOAC_2012_test.csv")) #load data
colnames(aragonite_data) <- c("Date", "Time", "Lat", "Long", "Pressure", "OmegaAr") #rename columns in dataframe

aragonite_data <- aragonite_data[-c(7,8)]

aragonite_data <- aragonite_data %>% #remove N/A values
  mutate(OmegaAr=replace(OmegaAr, OmegaAr==-999.000, NA)) %>%
  na.omit(aragonite_data)

aragonite_data<- aragonite_data[aragonite_data[, 5]<5,] #filter for surface observations

coordinates(aragonite_data)<-  ~ Long + Lat #transform into spatial points

zd<-zerodist(aragonite_data)

aragonite_var<-variogram(OmegaAr ~1, data=aragonite_data, alpha=c(0, 45, 90, 135))
plot(aragonite_var) #look for anisotropy and create variogram of aragonite values

aragonite_fit<-fit.variogram(aragonite_var,model=vgm(nugget=0.5,psill=0.3,range=2,model="Exp", anis=c(0, 0.3))) #fit a model to the values based on estimated nugget, sill, and range, and anisotropy
plot(aragonite_var,aragonite_fit)

aragonite_grid<-expand.grid(long,lat) #create grid for interpolation surface
colnames(aragonite_grid)<- c("long", "lat")
coordinates(aragonite_grid) <- ~ long + lat
gridded(aragonite_grid)=TRUE

aragonitekrige<-krige(OmegaAr ~ 1, aragonite_data, newdata=aragonite_grid, model=aragonite_fit) #run kriging on interpolation grid, based on best fit model

aragonite_raster<-raster(aragonitekrige, layer=1, values=TRUE) #transform krige object to raster
projection(aragonite_raster) <- CRS("+proj=longlat +datum=WGS84") #set CRS 
aragonite_raster_proj_2012 <- projectRaster(aragonite_raster, crs=CRS('+init=EPSG:6414'),method="ngb") #re-project to California Teale Albers Equal Area


#2007

aragonite_data <- read_csv(here("data/WCOAC_2007_test.csv")) #load data
colnames(aragonite_data) <- c("Date", "Time", "Lat", "Long", "Pressure", "OmegaAr") #rename columns in dataframe

aragonite_data <- aragonite_data[-c(7, 8, 9)]

aragonite_data <- aragonite_data %>% #remove N/A values
  mutate(OmegaAr=replace(OmegaAr, OmegaAr==-999.000, NA)) %>%
  na.omit(aragonite_data)

aragonite_data<- aragonite_data[aragonite_data[, 5]<5,] #filter for surface observations

coordinates(aragonite_data)<-  ~ Long + Lat #transform into spatial points

zd<-zerodist(aragonite_data)

aragonite_var<-variogram(OmegaAr ~1, data=aragonite_data, alpha=c(0, 45, 90, 135))
plot(aragonite_var) #look for anisotropy and create variogram of aragonite values

aragonite_fit<-fit.variogram(aragonite_var,model=vgm(nugget=0.2,psill=1,range=2,model="Exp", anis=c(0, 0.3))) #fit a model to the values based on estimated nugget, sill, and range, and anisotropy
plot(aragonite_var,aragonite_fit)

aragonite_grid<-expand.grid(long,lat) #create grid for interpolation surface
colnames(aragonite_grid)<- c("long", "lat")
coordinates(aragonite_grid) <- ~ long + lat
gridded(aragonite_grid)=TRUE

aragonitekrige<-krige(OmegaAr ~ 1, aragonite_data, newdata=aragonite_grid, model=aragonite_fit) #run kriging on interpolation grid, based on best fit model

aragonite_raster<-raster(aragonitekrige, layer=1, values=TRUE) #transform krige object to raster
projection(aragonite_raster) <- CRS("+proj=longlat +datum=WGS84") #set CRS 
aragonite_raster_proj_2007 <- projectRaster(aragonite_raster, crs=CRS('+init=EPSG:6414'),method="ngb") #re-project to California Teale Albers Equal Area

# 2013

aragonite_data <- read_csv(here("data/WCOAC_2013_test.csv")) #load data
colnames(aragonite_data) <- c("Date", "Time", "Lat", "Long", "Pressure", "OmegaAr") #rename columns in dataframe

aragonite_data <- aragonite_data %>% #remove N/A values
  mutate(OmegaAr=replace(OmegaAr, OmegaAr==-999.000, NA)) %>%
  na.omit(aragonite_data)

aragonite_data<- aragonite_data[aragonite_data[, 5]<5,] #filter for surface observations

coordinates(aragonite_data)<-  ~ Long + Lat #transform into spatial points

zd<-zerodist(aragonite_data)
aragonite_data<-aragonite_data[-zd[,2],] #remove observations taken at same coordinate point

aragonite_var<-variogram(OmegaAr ~1, data=aragonite_data, alpha=c(0, 45, 90, 135))
plot(aragonite_var) #look for anisotropy and create variogram of aragonite values

aragonite_fit<-fit.variogram(aragonite_var,model=vgm(nugget=0.2,psill=1,range=2,model="Exp", anis=c(0, 0.3))) #fit a model to the values based on estimated nugget, sill, and range, and anisotropy
plot(aragonite_var,aragonite_fit)

aragonite_grid<-expand.grid(long,lat) #create grid for interpolation surface
colnames(aragonite_grid)<- c("long", "lat")
coordinates(aragonite_grid) <- ~ long + lat
gridded(aragonite_grid)=TRUE

aragonitekrige<-krige(OmegaAr ~ 1, aragonite_data, newdata=aragonite_grid, model=aragonite_fit) #run kriging on interpolation grid, based on best fit model

aragonite_raster<-raster(aragonitekrige, layer=1, values=TRUE) #transform krige object to raster
projection(aragonite_raster) <- CRS("+proj=longlat +datum=WGS84") #set CRS 
aragonite_raster_proj_2013 <- projectRaster(aragonite_raster, crs=CRS('+init=EPSG:6414'),method="ngb") #re-project to California Teale Albers Equal Area

aragonitecruises <- (aragonite_raster_proj_2007+aragonite_raster_proj_2011+aragonite_raster_proj_2012+aragonite_raster_proj_2013)/4

aragonitecruises <- mask(aragonitecruises, poly_coast, inverse = TRUE) #Clip continuous raster
aragonitecruises <- mask(aragonitecruises, Canada, inverse = TRUE) #Clip raster layer to Canada layer



arag_crop <- mask(arag, poly_coast, inverse = TRUE) #Clip continuous raster
arag_crop <- mask(arag_crop, Canada, inverse = TRUE) #Clip raster layer to Canada layer

juranek_arag_crop <- mask(juranek_arag, poly_coast, inverse = TRUE) #Clip continuous raster
juranek_arag_crop <- mask(juranek_arag_crop, Canada, inverse = TRUE) #Clip raster layer to Canada layer

alin_arag_crop <- mask(alin_arag, poly_coast, inverse = TRUE) #Clip continuous raster
alin_arag_crop <- mask(alin_arag_crop, Canada, inverse = TRUE) #Clip raster layer to Canada layer



pal <- colorRampPalette(c("red", "white", "royalblue2")) 

tmap_mode("view")


tm_shape(aragonitecruises) +
  tm_raster(palette = pal(3),  breaks = seq(1.6,2.4, by=0.1),
             title="Aragonite Saturation State") + 
  tm_layout(basemaps = c('OpenStreetMap')) #Map of aragonite saturation state layer, showing range of values from 0.8 to 3 by 0.2 increments 

tm_shape(arag_crop) +
  tm_raster(palette = pal(3),  breaks = seq(1.0,2.8, by=0.1),
             title="Aragonite Saturation State") + 
  tm_layout(basemaps = c('OpenStreetMap')) #Map of aragonite saturation state layer, showing range of values from 0.8 to 3 by 0.2 increments 


  
do_crop <- mask(r_do_min, poly_coast, inverse = TRUE) #Clip continuous raster
do_crop <- mask(do_crop, Canada, inverse = TRUE) #Clip raster layer to Canada layer

tm_shape(do_crop) +
  tm_raster(palette = pal(3),
             title="Dissolved Oxygen") + 
  tm_layout(basemaps = c('OpenStreetMap')) #Map of aragonite saturation state layer, showing range of values from 0.8 to 3 by 0.2 increments 

```






####Create variogram
To quantify the relationship between changing aragonite saturation state and distance, the aragonite saturation state raster was used to create a semivariogram. The semi-variogram describes how the semi-variance  of a parameter increases with distance, revealing information on the spatial scale of decorrelation of that parameter. In this analysis, we used it to determine the relationship between variance in aragonite saturation state and distance. The semi-variogram revealed that the semi-variance in aragonite saturation state saturates (i.e. semi-variance ceases to increase as distance increases) at a distance of 2000 km, and a maximum semi-variance of 0.12 is reached at that point. We used a linear interpolation between the origin and the saturation point to relate variance in aragonite saturation state and distance. 
```{r variogram, eval = TRUE}
aragvar <- Variogram(arag, lag = 5000)
plot(aragvar)
```

##Step 2. Relate aragonite saturation state trends to each monitoring site
####Load inventory
This step can be done locally when updated versions of the monitoring inventory are available
```{r prep inventory, message = FALSE, warning = FALSE, results = 'hide'}
# import inventory
inventory <- read_csv(here("data/inventory.csv"))
```

####Tidy Inventory
1. Isolate OAH Focus Data Collection
2. Quantify Data Collection Frequency (measurements/year)
3. Remove NA coordinate entries from gliders
4. Transform latitude and longitude to numeric
5. Create subsets of data
```{r tidy inventory, message = FALSE, warning = FALSE, results = 'hide'}

#remove non OAH focus entries

oahfocus <- subset(inventory, OAHFocus == "OA" | OAHFocus == "H" | OAHFocus == "OAH")

#quantify frequencies
unique(oahfocus$MeasFreq)
oahfocus$MeasFreq[oahfocus$MeasFreq == 10] <- 52560
oahfocus$MeasFreq[oahfocus$MeasFreq == 60] <- 8760
oahfocus$MeasFreq[oahfocus$MeasFreq ==30] <- 17520
oahfocus$MeasFreq[oahfocus$MeasFreq == 20] <- 26280
oahfocus$MeasFreq[oahfocus$MeasFreq == 15] <- 35040
oahfocus$MeasFreq[oahfocus$MeasFreq == 5] <- 105120
oahfocus$MeasFreq[oahfocus$MeasFreq == 6] <- 87600
oahfocus$MeasFreq[oahfocus$MeasFreq == 180] <- 2920
oahfocus$MeasFreq[oahfocus$MeasFreq == 2] <- 262800
oahfocus$MeasFreq[oahfocus$MeasFreq == 0.25] <- 2102400
oahfocus$MeasFreq[oahfocus$MeasFreq == 3] <- 175200
oahfocus$MeasFreq[oahfocus$MeasFreq == 1] <- 525600
oahfocus$MeasFreq[oahfocus$MeasFreq == 120] <- 2920
oahfocus$MeasFreq[oahfocus$MeasFreq == 360] <- 1460
oahfocus$MeasFreq[oahfocus$MeasFreq == 720] <- 730
oahfocus$MeasFreq[oahfocus$MeasFreq =="Quarterly"] <- 4
oahfocus$MeasFreq[oahfocus$MeasFreq =="Annual"] <- 1
oahfocus$MeasFreq[oahfocus$MeasFreq =="Monthly"] <- 12
oahfocus$MeasFreq[oahfocus$MeasFreq =="Semi-annual"] <- 2
oahfocus$MeasFreq[oahfocus$MeasFreq =="Bi-weekly"] <- 26
oahfocus$MeasFreq[oahfocus$MeasFreq =="Seasonally"] <- 1
oahfocus$MeasFreq[oahfocus$MeasFreq =="1/4 second"] <- 126144000
oahfocus$MeasFreq[oahfocus$MeasFreq =="Bi-monthly"] <- 6
oahfocus$MeasFreq[oahfocus$MeasFreq =="5  Years"] <- 0.2
oahfocus$MeasFreq[oahfocus$MeasFreq =="Bi-weekly"] <- 26
oahfocus$MeasFreq[oahfocus$MeasFreq =="Variable"] <- 0
oahfocus$MeasFreq[oahfocus$MeasFreq =="Decadal"] <- 0.1
oahfocus$MeasFreq[oahfocus$MeasFreq =="Biennial"] <- 0.5
oahfocus$MeasFreq[oahfocus$MeasFreq =="Weekly"] <- 52
oahfocus$MeasFreq[oahfocus$MeasFreq =="Triennial"] <- 0.33333
oahfocus$MeasFreq[oahfocus$MeasFreq =="Trimester"] <- 3
oahfocus$MeasFreq[oahfocus$MeasFreq =="Daily"] <- 365
oahfocus$MeasFreq[oahfocus$MeasFreq =="< 6 hours"] <- 1460
oahfocus$MeasFreq[oahfocus$MeasFreq =="Once"] <- 0



unique(oahfocus$MeasFreq)

#remove NA coordinates
oahfocus <- oahfocus[!is.na(oahfocus$Latitude), ]
oahfocus <- oahfocus[!is.na(oahfocus$Longitude), ]

#remove spaces and transform to numeric
gsub(" ", "", oahfocus$Latitude)
gsub(" ", "", oahfocus$Longitude)
gsub("'<ca>'", "", oahfocus$Longitude)
oahfocus$Longitude<-as.numeric(oahfocus$Longitude)
oahfocus$Latitude<-as.numeric(oahfocus$Latitude)

#subsets
carbcomplete<-subset(oahfocus, DisCrbPmtr>1 | ISCrbPmtr > 1)
incomplete <- subset(oahfocus, DisCrbPmtr<2 & ISCrbPmtr < 2 & EndYr == "Present")
highfrequency<-subset(oahfocus, MeasFreq > 364)
highfreqcarbcomplete<-subset(oahfocus, MeasFreq > 364 & DisCrbPmtr>1 | MeasFreq > 364 & ISCrbPmtr > 1)
lowfrequency <- subset(oahfocus, MeasFreq < 365 & EndYr == "Present" & AssetType == "Shoreside Sensor" | AssetType == "Mooring" | AssetType == "Sample Site" | AssetType == "Shoresidesensor")

```

####Make spatial points object from inventory coordinates and its subsets
```{r make spatial objects from iventory, message = FALSE, warning = FALSE, results = 'hide'}
# isolate coordinate columns
coords <- cbind.data.frame(oahfocus$Longitude, oahfocus$Latitude)
carbcompletecoords <- cbind.data.frame(carbcomplete$Longitude, carbcomplete$Latitude)
incompletecoords <- cbind.data.frame(incomplete$Longitude, incomplete$Latitude)
highfrequencycoords <- cbind.data.frame(highfrequency$Longitude, highfrequency$Latitude)
lowfrequencycoords <- cbind.data.frame(lowfrequency$Longitude, lowfrequency$Latitude)
highfreqcarbcompletecoords <- cbind.data.frame(highfreqcarbcomplete$Longitude, highfreqcarbcomplete$Latitude)

# remove duplicate locations
deduped.coords<-unique(coords)
deduped.carbcomplete <- unique(carbcompletecoords)
deduped.incomplete <- unique(incompletecoords)
deduped.highfrequency <- unique(highfrequencycoords)
deduped.lowfrequency <- unique(lowfrequencycoords)
deduped.highfreqcarbcomplete <- unique(highfreqcarbcompletecoords)

# create spatial points objects
inventorycoords <- SpatialPoints(deduped.coords, CRS("+proj=longlat +ellps=WGS84"))
inventorycoords <- spTransform(inventorycoords, CRS('+init=EPSG:6414'))
carbcompletecoords <- SpatialPoints(deduped.carbcomplete, CRS("+proj=longlat +ellps=WGS84"))
carbcompletecoords <- spTransform(carbcompletecoords, CRS('+init=EPSG:6414'))
incompletecoords <- SpatialPoints(deduped.incomplete, CRS("+proj=longlat +ellps=WGS84"))
incompletecoords <- spTransform(incompletecoords, CRS('+init=EPSG:6414'))
highfreqcoords <- SpatialPoints(deduped.highfrequency, CRS("+proj=longlat +ellps=WGS84"))
highfreqcoords <- spTransform(highfreqcoords, CRS('+init=EPSG:6414'))
lowfreqcoords <- SpatialPoints(deduped.lowfrequency, CRS("+proj=longlat +ellps=WGS84"))
lowfreqcoords <- spTransform(lowfreqcoords, CRS('+init=EPSG:6414'))
highfreqcarbcompletecoords <- SpatialPoints(deduped.highfreqcarbcomplete, CRS("+proj=longlat +ellps=WGS84"))
highfreqcarbcompletecoords <- spTransform(highfreqcarbcompletecoords, CRS('+init=EPSG:6414'))

```

####Create voronoi polygons and rasterize the results
We used Voronoi polygons to divide the ocean into regions based on spatial proximity to each monitoring asset.23 We assigned a polygon identification number to each polygon and then gridded the Voronoi polygons, while maintaining the polygon identification numbers. 
```{r voronoi,  message = FALSE, warning = FALSE, results = 'hide'}

# create voronoi polygons
vor <-voronoi(inventorycoords)
carbcompletevor <- voronoi(carbcompletecoords)
incompletevor <- voronoi(incompletecoords)
highfreqvor <- voronoi(highfreqcoords)
lowfreqvor <- voronoi(lowfreqcoords)

# rasterize polygons
vorraster<- rasterize(vor, r_sst_min, "id")
carbcompletevorraster<- rasterize(carbcompletevor, r_sst_min, "id")
incompletevorraster<- rasterize(incompletevor, r_sst_min, "id")
highfreqvorraster<- rasterize(highfreqvor, r_sst_min, "id")
lowfreqvorraster<- rasterize(lowfreqvor, r_sst_min, "id")

```

####Create OA layer
We assigned the parameter value of all locations with the same polygon identification number (i.e. nearest to the same monitoring asset) to the measured value of the cell containing the monitoring asset associated with that same polygon identification number. This step resulted in a map of aragonite saturation state across the West Coast estimated by the empirical model output at each monitoring site. Thus, a monitoring network with 20 assets would result in a map made up of 20 chunks of area, each with different values of aragonite saturation state based on the estimated value at the nearest monitoring asset. 
```{r polygons}
#extract aragonite saturation state value for each monitoring site
sitearag<- raster::extract(arag, inventorycoords, method='simple', df=TRUE)
carbcompletesitearag<- raster::extract(arag, carbcompletecoords, method='simple', df=TRUE)
highfreqsitearag<- raster::extract(arag, highfreqcoords, method='simple', df=TRUE)
# rename column names of sitesstrange
colnames(sitearag)<-c("id", "Arag")
colnames(carbcompletesitearag)<-c("id", "Arag")
colnames(highfreqsitearag)<-c("id", "Arag")
# substitute polygon id for monitoring site sea surface temerature of that polygon
polygonarag<-subs(vorraster, sitearag, by="id", which="Arag", subsWithNA=FALSE)
carbcompletepolygonarag <- subs(carbcompletevorraster, carbcompletesitearag, by="id", which="Arag", subsWithNA=FALSE)
highfreqpolygonarag <- subs(highfreqvorraster, highfreqsitearag, by="id", which="Arag", subsWithNA=FALSE)
```

####Determine semivariance of aragonite discrepancy
We then used the empirical model outputs created using the continuous environmental layers to find the difference between the empirical model outputs at every location in the ocean and the empirical model outputs for the nearest monitoring asset. The result is an aragonite saturation state discrepancy value that describes how different acidification conditions are at any point on the West Coast as compared to these conditions at the nearest data collection location. In places where this value is high, a monitoring asset is not describing OA conditions well. In places where this value is low, a monitoring asset describes OA conditions very well. In the future, when aragonite saturation state models are available on a regional scale, outputs from such models could replace our empirical model outputs.  
```{r semivariance}
#vij = (xi-xj)^2/2

vij<- (arag-polygonarag)^2/2
carbcompletevij <- (arag-carbcompletepolygonarag)^2/2
highfreqvij <- (arag-highfreqpolygonarag)^2/2
```

##Step 3. Geographic and oceanographic distance
####Oceanographic distance
The inverse of the linear relationship from the semi-variogram was applied to the semi-variance calculated above, yielding a map showing the “oceanographic distance” between each cell in our study region and the nearest monitoring asset. We define oceanographic distance as the effective distance between any location and the nearest monitoring asset, based on the similarity of oceanographic conditions that determine OA conditions between the two locations. A cell with high oceanographic distance has different acidification conditions than the nearest monitoring asset, and a cell with low oceanographic distance has similar acidification conditions to the nearest monitoring asset. 
```{r oceanographic distance,  message = FALSE, warning = FALSE, results = 'hide'}

#variogram does not saturate: develop an equation to describe relationship using square root function...

model <- lm(aragvar@variogram[["gamma"]] ~ 0 + I((aragvar@variogram[["distance"]])))


#sqrootmodel <- lm(aragvar@variogram[["gamma"]] ~ 0 + I(sqrt(aragvar@variogram[["distance"]])))

#p value < 2e-16

xbar<-aragvar@variogram[["distance"]]
#ybar<-sqrt(xbar)*sqrootmodel$coefficients[1]
ybar<-(xbar)*model$coefficients[1]

ggplot()+
  geom_point(aes(aragvar@variogram[["distance"]], aragvar@variogram[["gamma"]]), color = "red")+
  geom_point(aes(xbar, ybar), color = "blue")+
  ylim(0, 0.15)+
  theme_bw()+
  ggtitle('Variogram (red) and predictive model (blue)')+
  xlab('Distance Between Points (m)')+
  ylab('Semivariance of Aragonite Discrepancy')+
  theme(text = element_text(size = 10, family="serif"))

#find inverse of nonlinear model:
#semivariance = 5.871094 e-08 * (distance)
#distance = (semivariance/(5.871094 e-08)

#oceanographicdistance = (vij/0.0001504855)^2/(1000^2)
#carbcompleteoceanographicdistance = (carbcompletevij/0.0001504855)^2/(1000^2)
#maxhighfreqoceanographicdistance = (highfreqvij/0.0001504855)^2/(1000^2)

oceanographicdistance = (vij/(5.871094e-08))/(1000)
carbcompleteoceanographicdistance = (carbcompletevij/(5.871094e-08))/(1000)
highfreqoceanographicdistance = (highfreqvij/(5.871094e-08))/(1000)


```

####Geographic distance
Determine geographic distance from the nearest monitoring point
```{r geographic distance}
distance<-distanceFromPoints(oceanographicdistance, inventorycoords)/1000
carbcompletedistance<-distanceFromPoints(carbcompleteoceanographicdistance, carbcompletecoords)/1000
highfreqdistance<-distanceFromPoints(highfreqoceanographicdistance, highfreqcoords)/1000
```

##Step 4. Find Gaps
####Combine ingredients
We used a Euclidean distance approach to combine geographic distance and oceanographic distance into a single “gap” layer. Thus, a gap in the network is a place where oceanographic conditions are different from conditions at the nearest data collection location, a place that is geographically far from the nearest data collection, or a place with both of these characteristics. When combining these two, we weighted the oceanographic distance term by multiplying it by the unitless ratio of the maximum value of geographic distance and the maximum value of the oceanographic distance. 
```{r find gaps, warning=FALSE, message=FALSE}

#calculate gaps

weight = maxValue(distance)/maxValue(oceanographicdistance)

gap<-(sqrt((distance)^2+(weight*oceanographicdistance)^2))
carbcompletegap<-(sqrt((carbcompletedistance)^2+(weight*carbcompleteoceanographicdistance)^2))
highfreqgap<-(sqrt((highfreqdistance)^2+(weight*highfreqoceanographicdistance)^2))


gap <- crop(gap, ext_study)
carbcompletegap <- crop(carbcompletegap, ext_study)
highfreqgap <- crop(highfreqgap, ext_study)
```

####Map Gaps
```{r map gaps, echo=FALSE, warning=FALSE, message=FALSE, fig.show='hold', out.width = '25%', fig.height = 4, fig.width = 2}

#run this rmd document and then run manuscript_maps.R to produce pngs used in manuscript. the following code produces maps on resilienses.github.io

tmap_mode("plot")

pal <- colorRampPalette(c("royalblue2", "white", "red"))

tm_shape(gap)+
  tm_raster(palette = pal(10), colorNA = 'grey87', alpha = 0.8, auto.palette.mapping = FALSE, legend.show = FALSE, breaks = c(0,50,100,300, 500))+
  tm_layout(main.title = "Gaps", fontfamily = "serif", fontface = "bold", main.title.size = 0.7, main.title.position = "center", outer.margins = c(0.05, 0.05, 0.05, 0.05))+
  tm_shape(poly_coast)+
  tm_polygons()+
  tm_shape(Canada)+
  tm_polygons()+
  tm_grid(projection = "longlat", lwd = 0.1, n.x = 3, n.y = 6, labels.inside.frame = FALSE, labels.size = 0.6)+
  tmap_options(max.raster = c(plot = 45955000, view = 45955000))

tm_shape(carbcompletegap)+
  tm_raster(palette = pal(10), colorNA = 'grey87', alpha = 0.8, auto.palette.mapping = FALSE, legend.show = FALSE,  breaks = c(0, 30, 90, 270, 810, 2000))+
  tm_layout(main.title = "Aragonite Measurement Gaps", fontfamily = "serif", fontface = "bold", main.title.size = 0.7, main.title.position = "center", outer.margins = c(0.05, 0.05, 0.05, 0.05))+
  tm_shape(poly_coast)+
  tm_polygons()+
  tm_shape(Canada)+
  tm_polygons()+
  tm_grid(projection = "longlat", lwd = 0.1, n.x = 3, n.y = 6, labels.inside.frame = FALSE, labels.size = 0.6)+
  tmap_options(max.raster = c(plot = 45955000, view = 45955000))

tm_shape(highfreqgap)+
  tm_raster(palette = pal(10), colorNA = 'grey87', alpha = 0.8, auto.palette.mapping = FALSE, legend.show = FALSE,  breaks = c(0, 30, 90, 270, 810, 2000))+
  tm_layout(main.title = "Daily Monitoring Gaps", fontfamily = "serif", fontface = "bold", main.title.size = 0.7, main.title.position = "center", outer.margins = c(0.05, 0.05, 0.05, 0.05))+
  tm_shape(poly_coast)+
  tm_polygons()+
  tm_shape(Canada)+
  tm_polygons()+
  tm_grid(projection = "longlat", lwd = 0.1, n.x = 3, n.y = 6, labels.inside.frame = FALSE, labels.size = 0.6)+
  tmap_options(max.raster = c(plot = 45955000, view = 45955000))

#tm_shape(gap)+
#  tm_raster(title = "Effective Distance to Nearest Monitoring (km)", palette = #pal(10), colorNA = 'grey87', alpha = 1, auto.palette.mapping = FALSE, #legend.show = TRUE, breaks = c(0, 100, 200, 300, 400, 500))+
#  tm_layout(main.title = "Effective Distance to Nearest Monitoring (km)", #bg.color = "white", main.title.position = c("center", "top"), fontfamily = #"serif", fontface = "bold", legend.only = TRUE, legend.just = "center", #legend.title.size = 0.7, legend.text.size= 0.5)+
#  tm_shape(poly_coast)+
#  tm_polygons()+
#  tm_shape(Canada)+
#  tm_polygons()+
#  tm_grid(projection = "longlat", lwd = 0.1, n.x = 3, n.y = 6, labels.size = #0.6)
#tmap_options(max.raster = c(plot = 45955000, view = 45955000))

```
