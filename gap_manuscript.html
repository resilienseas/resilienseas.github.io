<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Manuscript Gap Analysis</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">ResilienSeas</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About ResilienSeas</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-flask"></span>
     
    Analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="hotspots.html">Ocean Acidfication Hotspot and MPA Analysis for WCODP</a>
    </li>
    <li>
      <a href="gaps.html">Monitoring Inventory Gap Analysis for WCODP</a>
    </li>
    <li>
      <a href="LTERanalysis.html">Manuscript LTER Analysis</a>
    </li>
    <li>
      <a href="gap_manuscript.html">Manuscript Gap Analysis</a>
    </li>
  </ul>
</li>
<li>
  <a href="tools.html">
    <span class="fa fa-wrench"></span>
     
    Tools
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Manuscript Gap Analysis</h1>

</div>


<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Given the existing monitoring network, our analysis locates the best site for the next monitoring asset, thereby filling in monitoring network gaps one asset at a time, based off the sites that already are in place. In this analysis we utilized methods that fall in the middle of the spectrum defined by other works in this realm (see Asch et al. (2003) for a more simplistic approach, and Frolov et al. 2013 for a more involved approach). These decisions were made due to the constraints of the data we used (spatial metadata as opposed to time series and satellite data) as well as the goal of working with policymakers and non-scientist end users. The result is an analysis that provides specific spatial information on relative sampling of ocean acidification on the West Coast. Monitoring networks are geographic objects, and it might seem that the ideal network would evenly spaced across the ocean. However, the ocean is not uniform: some places in the ocean are more dynamic, both spatially and temporally, than others. This effect can be illustrated with an example from the Santa Barbara Channel (see LTER analysis). Thus, where the ocean is highly dynamic, an ideal monitoring network will have more closely clustered assets than in places that are more static.</p>
</div>
<div id="step-1.-manipulate-sea-surface-temperature-and-dissolved-oxygen-estimate-make-aragonite-saturation-state" class="section level2">
<h2>Step 1. Manipulate sea surface temperature and dissolved oxygen estimate make aragonite saturation state</h2>
<div id="setup" class="section level4">
<h4>Setup</h4>
<p>Load packages, set cache, define study area</p>
<pre class="r"><code>if (!require(pacman)) install.packages(&quot;pacman&quot;)</code></pre>
<pre><code>## Loading required package: pacman</code></pre>
<pre class="r"><code>library(pacman)
p_load(
  tidyverse, here, glue,
  raster,
  sdmpredictors, dismo, 
  deldir, 
  mapview,
  tmap,
  ggplot2,
  rgdal,
  gstat,
  usdm,
  knitr,
  tmap,
  rnaturalearth, 
  grid,
  gridExtra)
# custom R package: oatools
devtools::load_all(here(&quot;../oatools&quot;)) # for developing</code></pre>
<pre><code>## Loading oatools</code></pre>
<pre><code>## Warning in setup_ns_exports(path, export_all, export_imports): Objects
## listed as exports, but not present in namespace: find_gaps</code></pre>
<pre class="r"><code>#library(oatools) # devtools::install_github(&quot;resilinseas/oatools&quot;) # for eventual production
# paths &amp; variables ----
dir_data        &lt;- here(&quot;data&quot;)
dir_sdmdata_old &lt;- here(&quot;data/sdmpredictors&quot;)
dir_cache       &lt;- here(&quot;cache&quot;)
dir_sdmdata     &lt;- here(&quot;cache/sdmpredictors&quot;)
SST_tif &lt;- here(&quot;data/sst_mean.tif&quot;)
DO_tif  &lt;- here(&quot;data/do_mean.tif&quot;)

# reorganize dirs so &quot;cache&quot; is always local and ignored by git, vs all in &quot;data&quot; tracked by git &amp; pushed to github
if (!dir.exists(dir_data))    dir.create(dir_data)
if (!dir.exists(dir_cache))   dir.create(dir_cache)
if (!dir.exists(dir_sdmdata) &amp; dir.exists(dir_sdmdata_old))
  file.rename(dir_sdmdata_old, dir_sdmdata)
if (!dir.exists(dir_sdmdata)) dir.create(dir_sdmdata)
 list&lt;- list_layers(&quot;Bio-ORACLE&quot;)

# extent of NE Pacific study area, for cropping rasters
ext_study &lt;- extent(-600000, 340000, -590000, 1210000)
crs_study &lt;- &#39;+init=EPSG:6414&#39;

# extent of larger area for voronoi polygons
ext_study_vor &lt;- extent(-800000, 340000, -800000, 1300000)
ext_study_alin &lt;- extent(-6000000, 340000, -600000, 430000)
ext_study_juranek &lt;- extent(-6000000, 340000, -900000, 1210000)

# import shapefiles for cropping to coast
poly_coast&lt;- readOGR(dsn=path.expand(&quot;/Users/raetaylor-burns/Desktop/RTB/gapanalysismanuscript/Export_Output_2&quot;), layer=&quot;Export_Output_2&quot;)</code></pre>
<pre><code>## OGR data source with driver: ESRI Shapefile 
## Source: &quot;/Users/raetaylor-burns/Desktop/RTB/gapanalysismanuscript/Export_Output_2&quot;, layer: &quot;Export_Output_2&quot;
## with 52 features
## It has 55 fields
## Integer64 fields read as strings:  OBJECTID POPULATION POP2010 WHITE BLACK AMERI_ES ASIAN HAWN_PI HISPANIC OTHER MULT_RACE MALES FEMALES AGE_UNDER5 AGE_5_9 AGE_10_14 AGE_15_19 AGE_20_24 AGE_25_34 AGE_35_44 AGE_45_54 AGE_55_64 AGE_65_74 AGE_75_84 AGE_85_UP HOUSEHOLDS HSEHLD_1_M HSEHLD_1_F MARHH_CHD MARHH_NO_C MHH_CHILD FHH_CHILD FAMILIES HSE_UNITS VACANT OWNER_OCC RENTER_OCC</code></pre>
<pre class="r"><code>Canada&lt;- readOGR(dsn=path.expand(&quot;/Users/raetaylor-burns/Desktop/RTB/gapanalysismanuscript/Canada&quot;), layer=&quot;Canada&quot;)</code></pre>
<pre><code>## OGR data source with driver: ESRI Shapefile 
## Source: &quot;/Users/raetaylor-burns/Desktop/RTB/gapanalysismanuscript/Canada&quot;, layer: &quot;Canada&quot;
## with 13 features
## It has 2 fields</code></pre>
<pre class="r"><code>states&lt;- readOGR(dsn=path.expand(&quot;/Users/raetaylor-burns/Desktop/RTB/gapanalysismanuscript/cb_2016_us_state_20m&quot;), layer=&quot;cb_2016_us_state_20m&quot;)</code></pre>
<pre><code>## OGR data source with driver: ESRI Shapefile 
## Source: &quot;/Users/raetaylor-burns/Desktop/RTB/gapanalysismanuscript/cb_2016_us_state_20m&quot;, layer: &quot;cb_2016_us_state_20m&quot;
## with 52 features
## It has 9 fields
## Integer64 fields read as strings:  ALAND AWATER</code></pre>
<pre class="r"><code>estuaries&lt;- readOGR(dsn=path.expand(&quot;/Users/raetaylor-burns/Desktop/RTB/gapanalysismanuscript/estuaries&quot;), layer=&quot;estuaries&quot;)</code></pre>
<pre><code>## OGR data source with driver: ESRI Shapefile 
## Source: &quot;/Users/raetaylor-burns/Desktop/RTB/gapanalysismanuscript/estuaries&quot;, layer: &quot;estuaries&quot;
## with 931 features
## It has 1 fields</code></pre>
<pre class="r"><code>sf_puget&lt;- readOGR(dsn=path.expand(&quot;/Users/raetaylor-burns/Desktop/RTB/gapanalysismanuscript/water_bodies_carto&quot;), layer=&quot;water_bodies_carto&quot;)</code></pre>
<pre><code>## OGR data source with driver: ESRI Shapefile 
## Source: &quot;/Users/raetaylor-burns/Desktop/RTB/gapanalysismanuscript/water_bodies_carto&quot;, layer: &quot;water_bodies_carto&quot;
## with 1918 features
## It has 1 fields</code></pre>
<pre class="r"><code>#load shapefiles
poly_coast &lt;- spTransform(poly_coast, crs(crs_study))
Canada &lt;- spTransform(Canada, crs(crs_study))
states &lt;- spTransform(states, crs(crs_study))
estuaries &lt;- spTransform(estuaries, crs(crs_study))
sf_puget &lt;- spTransform(sf_puget, crs(crs_study))


# commenting out unused exploratory commands
# list_datasets() %&gt;% View()
# list_layers()
# list_layers(&quot;Bio-ORACLE&quot;) %&gt;% View()
# list_layers(&quot;MARSPEC&quot;) %&gt;% View()
# list_layers(&quot;WorldClim&quot;) %&gt;% View()
# list&lt;- list_layers(&quot;Bio-ORACLE&quot;)

# sea surface temperature
# devtools::load_all(here(&quot;../oatools&quot;)) # for use while developing
r_sst &lt;- lyr_to_tif(
  lyr = &quot;BO_sstmean&quot;, 
  tif = here(&quot;data/sst_mean.tif&quot;),
  crs = crs_study,
  dir_sdm_cache = dir_sdmdata,
  extent_crop   = ext_study_vor, 
  redo=T, fill_na=TRUE, fill_window=11)</code></pre>
<pre><code>## lyr_to_tif() messages...</code></pre>
<pre><code>##   loading layer from sdmpredictors and projecting</code></pre>
<pre><code>## Warning in rgdal::rawTransform(projto_int, projfrom, nrow(xy), xy[, 1], :
## 1834961 projected point(s) not finite</code></pre>
<pre><code>##   cropping raster to extent</code></pre>
<pre><code>##   filling in missing (NA) values with focal window</code></pre>
<pre><code>##   writing raster to tif</code></pre>
<pre class="r"><code># r_sst_alin &lt;- crop(r_sst, ext_study)-0.7
# r_sst_juranek &lt;- crop(r_sst, ext_study)-0.7

r_sst_alin &lt;- crop(r_sst, ext_study_alin) - 0.7
r_sst_juranek &lt;- crop(r_sst, ext_study_juranek) - 0.7

n_na        &lt;- sum(is.na(raster::getValues(r_sst)))


plot(r_sst)</code></pre>
<p><img src="gap_manuscript_files/figure-html/packages%20/%20cache-1.png" width="672" /></p>
<pre class="r"><code>#BO_sstmean
#BO_dissox</code></pre>
</div>
<div id="create-sstdo-rasters-from-bio-oracle-data" class="section level4">
<h4>Create SST/DO rasters from bio-oracle data</h4>
<p>Aragonite saturation state is the gold standard in an ocean acidification monitoring network, as this measurement has direct biological implications.9 However, the variables needed to calculate aragonite saturation state are not yet measured at a sufficient spatial-temporal resolution to identify highly variable locations across the study region. While this raw data could theoretically be replaced by a high-resolution model that would explicitly account for physical, chemical, and biological oceanographic processes, and integrate a variety of input data, such models are not yet available (although some are under development). In the absence of a model or data to describe aragonite saturation state, we used temperature and dissolved oxygen as proxies, because they are strongly positively correlated with aragonite saturation state.</p>
<pre class="r"><code># from observations, units in ml/l
r_do &lt;- lyr_to_tif(
  lyr = &quot;BO_dissox&quot;, 
  tif = here(&quot;data/do_mean.tif&quot;),
  crs = crs_study,
  dir_sdm_cache = dir_sdmdata,
  extent_crop   = ext_study_vor, 
  redo=T, fill_na=TRUE, fill_window=11)</code></pre>
<pre><code>## lyr_to_tif() messages...</code></pre>
<pre><code>##   loading layer from sdmpredictors and projecting</code></pre>
<pre><code>## Warning in rgdal::rawTransform(projto_int, projfrom, nrow(xy), xy[, 1], :
## 1834961 projected point(s) not finite</code></pre>
<pre><code>##   cropping raster to extent</code></pre>
<pre><code>##   filling in missing (NA) values with focal window</code></pre>
<pre><code>##   writing raster to tif</code></pre>
<pre class="r"><code>#units to micromol/kg
 r_do &lt;- r_do*(1000/(0.022391*1027))

r_do_alin &lt;- crop(r_do, ext_study_alin)
r_do_juranek &lt;- crop(r_do, ext_study_juranek)

plot(r_sst_alin)</code></pre>
<p><img src="gap_manuscript_files/figure-html/bio-Oracle-1.png" width="672" /></p>
</div>
<div id="use-juranek-2009-and-alin-2012-model-to-create-ocean-acidification-layer-for-the-study-region" class="section level4">
<h4>Use Juranek 2009 and Alin 2012 model to create ocean acidification layer for the study region</h4>
<p>At a sub-regional scale, empirically validated models have been developed that predict aragonite saturation state based on temperature and dissolved oxygen measurements. Our analysis utilized equation II from Alin et al. (2012) in the southern part of the study region and equation 3 from Juranek et al. (2009) in the northern part of the study region. We then created a “worst-case scenario” aragonite saturation state raster using the minimum sea surface temperature and dissolved oxygen values from each ocean area.</p>
<pre class="r"><code>#juranek aragonite
j0 = 9.242*10^-1
j1 = 4.492*10^-3
j2 = 9.40 * 10^-4
jo2r = 140
jtr = 8
juranek_arag &lt;- j0 + j1 * (r_do_juranek-jo2r) + j2 * (r_do_juranek-jo2r) * (r_sst_juranek-jtr)

#alin aragonite
a0 = 1.112
a1 = 9.59*10^-2
a2 = 3.54*10^-3
a3 = 5.91*10^-4
ao2r = 138.46
atr = 10.28

alin_arag &lt;- a0 + a1 * (r_sst_alin-atr) + a2 * (r_do_alin-ao2r) + a3 * (r_sst_alin-atr) * (r_do_alin-ao2r)</code></pre>
</div>
<div id="combine-model-outputs" class="section level4">
<h4>Combine model outputs</h4>
<p>To reduce the effect of the abrupt change in aragonite saturation state at the boundary between the two models, the mean of the two model outputs was used to predict aragonite saturation state in waters between Eureka and Fort Bragg, a distance of about 100 miles.</p>
<pre class="r"><code># 2 arag models, mean in between

arag &lt;- mosaic(alin_arag, juranek_arag, fun = mean)

midhigh &lt;- extent(-6000000, 340000, 260000, 1210000)
midhigh &lt;- crop(juranek_arag, midhigh)

midlow &lt;- extent(-6000000, 340000, -600000, 110000)
midlow &lt;- crop(alin_arag, midlow)

arag &lt;- mosaic(arag, midhigh, fun = mean)

arag &lt;- mosaic(arag, midlow, fun = mean)
arag &lt;- crop(arag, ext_study)

arag_clipped &lt;- mask(arag, poly_coast, inverse = TRUE) #Clip continuous raster
arag_clipped &lt;- mask(arag_clipped, estuaries, inverse = TRUE) #Clip continuous raster
arag_clipped &lt;- mask(arag_clipped, sf_puget, inverse = TRUE) #Clip continuous raster



plot(arag_clipped)</code></pre>
<p><img src="gap_manuscript_files/figure-html/model%20comparison-1.png" width="672" /></p>
</div>
<div id="create-variogram" class="section level4">
<h4>Create variogram</h4>
<p>To quantify the relationship between changing aragonite saturation state and distance, the aragonite saturation state raster was used to create a semivariogram. The semi-variogram describes how the semi-variance of a parameter increases with distance, revealing information on the spatial scale of decorrelation of that parameter. In this analysis, we used it to determine the relationship between variance in aragonite saturation state and distance. The semi-variogram revealed that the semi-variance in aragonite saturation state saturates (i.e. semi-variance ceases to increase as distance increases) at a distance of 2000 km, and a maximum semi-variance of 0.12 is reached at that point. We used a linear interpolation between the origin and the saturation point to relate variance in aragonite saturation state and distance.</p>
<pre class="r"><code>aragvar &lt;- Variogram(arag_clipped, cutoff = 500000)
plot(aragvar)</code></pre>
<p><img src="gap_manuscript_files/figure-html/variogram-1.png" width="672" /></p>
</div>
</div>
<div id="step-2.-relate-aragonite-saturation-state-trends-to-each-monitoring-site" class="section level2">
<h2>Step 2. Relate aragonite saturation state trends to each monitoring site</h2>
<div id="load-inventory" class="section level4">
<h4>Load inventory</h4>
<p>This step can be done locally when updated versions of the monitoring inventory are available</p>
<pre class="r"><code># import inventory
inventory &lt;- read_csv(here(&quot;data/inventory.csv&quot;))</code></pre>
</div>
<div id="tidy-inventory" class="section level4">
<h4>Tidy Inventory</h4>
<ol style="list-style-type: decimal">
<li>Isolate OAH Focus Data Collection</li>
<li>Quantify Data Collection Frequency (measurements/year)</li>
<li>Remove NA coordinate entries from gliders</li>
<li>Transform latitude and longitude to numeric</li>
<li>Create subsets of data</li>
</ol>
</div>
<div id="make-spatial-points-object-from-inventory-coordinates-and-its-subsets" class="section level4">
<h4>Make spatial points object from inventory coordinates and its subsets</h4>
<pre class="r"><code># isolate coordinate columns
coords &lt;- cbind.data.frame(oahfocus$Longitude, oahfocus$Latitude)
carbcompletecoords &lt;- cbind.data.frame(carbcomplete$Longitude, carbcomplete$Latitude)
incompletecoords &lt;- cbind.data.frame(incomplete$Longitude, incomplete$Latitude)
highfrequencycoords &lt;- cbind.data.frame(highfrequency$Longitude, highfrequency$Latitude)
lowfrequencycoords &lt;- cbind.data.frame(lowfrequency$Longitude, lowfrequency$Latitude)
highfreqcarbcompletecoords &lt;- cbind.data.frame(highfreqcarbcomplete$Longitude, highfreqcarbcomplete$Latitude)

calcoficoords &lt;- cbind.data.frame(calcofi$Longitude, calcofi$Latitude)

# remove duplicate locations
deduped.coords&lt;-unique(coords)
deduped.carbcomplete &lt;- unique(carbcompletecoords)
deduped.incomplete &lt;- unique(incompletecoords)
deduped.highfrequency &lt;- unique(highfrequencycoords)
deduped.lowfrequency &lt;- unique(lowfrequencycoords)
deduped.highfreqcarbcomplete &lt;- unique(highfreqcarbcompletecoords)

# create spatial points objects
inventorycoords &lt;- SpatialPoints(deduped.coords, CRS(&quot;+proj=longlat +ellps=WGS84&quot;))
inventorycoords &lt;- spTransform(inventorycoords, CRS(&#39;+init=EPSG:6414&#39;))

carbcompletecoords &lt;- SpatialPoints(deduped.carbcomplete, CRS(&quot;+proj=longlat +ellps=WGS84&quot;))
carbcompletecoords &lt;- spTransform(carbcompletecoords, CRS(&#39;+init=EPSG:6414&#39;))
highfreqcoords &lt;- SpatialPoints(deduped.highfrequency, CRS(&quot;+proj=longlat +ellps=WGS84&quot;))
highfreqcoords &lt;- spTransform(highfreqcoords, CRS(&#39;+init=EPSG:6414&#39;))

calcoficoords &lt;- SpatialPoints(calcoficoords, CRS(&quot;+proj=longlat +ellps=WGS84&quot;))
calcoficoords &lt;- spTransform(calcoficoords, CRS(&#39;+init=EPSG:6414&#39;))

lowfreqcoords &lt;- SpatialPoints(deduped.lowfrequency, CRS(&quot;+proj=longlat +ellps=WGS84&quot;))
lowfreqcoords &lt;- spTransform(lowfreqcoords, CRS(&#39;+init=EPSG:6414&#39;))

highfreqcarbcompletecoords &lt;- SpatialPoints(deduped.highfreqcarbcomplete, CRS(&quot;+proj=longlat +ellps=WGS84&quot;))
highfreqcarbcompletecoords &lt;- spTransform(highfreqcarbcompletecoords, CRS(&#39;+init=EPSG:6414&#39;))

incompletecoords &lt;- SpatialPoints(deduped.incomplete, CRS(&quot;+proj=longlat +ellps=WGS84&quot;))
incompletecoords &lt;- spTransform(incompletecoords, CRS(&#39;+init=EPSG:6414&#39;))

calcofiarag &lt;- raster::extract(arag, calcoficoords, method=&#39;simple&#39;, df=TRUE)
meancalcofi &lt;- mean(calcofiarag$layer, na.rm= TRUE)

relerr &lt;- (meancalcofi-2.2425)/2.2425

# account for uncertainty 
arag_max &lt;- arag*(1+relerr)

arag_min &lt;- arag*(1-relerr)</code></pre>
</div>
<div id="create-voronoi-polygons-and-rasterize-the-results" class="section level4">
<h4>Create voronoi polygons and rasterize the results</h4>
<p>We used Voronoi polygons to divide the ocean into regions based on spatial proximity to each monitoring asset.23 We assigned a polygon identification number to each polygon and then gridded the Voronoi polygons, while maintaining the polygon identification numbers.</p>
<pre class="r"><code># create voronoi polygons
vor &lt;-voronoi(inventorycoords)
carbcompletevor &lt;- voronoi(carbcompletecoords)
incompletevor &lt;- voronoi(incompletecoords)
highfreqvor &lt;- voronoi(highfreqcoords)
lowfreqvor &lt;- voronoi(lowfreqcoords)

# rasterize polygons
vorraster&lt;- rasterize(vor, r_sst, &quot;id&quot;)
carbcompletevorraster&lt;- rasterize(carbcompletevor, r_sst, &quot;id&quot;)
incompletevorraster&lt;- rasterize(incompletevor, r_sst, &quot;id&quot;)
highfreqvorraster&lt;- rasterize(highfreqvor, r_sst, &quot;id&quot;)
lowfreqvorraster&lt;- rasterize(lowfreqvor, r_sst, &quot;id&quot;)</code></pre>
</div>
<div id="create-oa-layer" class="section level4">
<h4>Create OA layer</h4>
<p>We assigned the parameter value of all locations with the same polygon identification number (i.e. nearest to the same monitoring asset) to the measured value of the cell containing the monitoring asset associated with that same polygon identification number. This step resulted in a map of aragonite saturation state across the West Coast estimated by the empirical model output at each monitoring site. Thus, a monitoring network with 20 assets would result in a map made up of 20 chunks of area, each with different values of aragonite saturation state based on the estimated value at the nearest monitoring asset.</p>
<pre class="r"><code>#extract aragonite saturation state value for each monitoring site
sitearag_max&lt;- raster::extract(arag_max, inventorycoords, method=&#39;simple&#39;, df=TRUE)
carbcompletesitearag_max&lt;- raster::extract(arag_max, carbcompletecoords, method=&#39;simple&#39;, df=TRUE)
highfreqsitearag_max&lt;- raster::extract(arag_max, highfreqcoords, method=&#39;simple&#39;, df=TRUE)
# rename column names of sitesstrange
colnames(sitearag_max)&lt;-c(&quot;id&quot;, &quot;Arag&quot;)
colnames(carbcompletesitearag_max)&lt;-c(&quot;id&quot;, &quot;Arag&quot;)
colnames(highfreqsitearag_max)&lt;-c(&quot;id&quot;, &quot;Arag&quot;)
# substitute polygon id for monitoring site sea surface temerature of that polygon
polygonarag_max&lt;-subs(vorraster, sitearag_max, by=&quot;id&quot;, which=&quot;Arag&quot;, subsWithNA=FALSE)
carbcompletepolygonarag_max &lt;- subs(carbcompletevorraster, carbcompletesitearag_max, by=&quot;id&quot;, which=&quot;Arag&quot;, subsWithNA=FALSE)
highfreqpolygonarag_max &lt;- subs(highfreqvorraster, highfreqsitearag_max, by=&quot;id&quot;, which=&quot;Arag&quot;, subsWithNA=FALSE)

sitearag_min&lt;- raster::extract(arag_min, inventorycoords, method=&#39;simple&#39;, df=TRUE)
carbcompletesitearag_min&lt;- raster::extract(arag_min, carbcompletecoords, method=&#39;simple&#39;, df=TRUE)
highfreqsitearag_min&lt;- raster::extract(arag_min, highfreqcoords, method=&#39;simple&#39;, df=TRUE)
# rename column names of sitesstrange
colnames(sitearag_min)&lt;-c(&quot;id&quot;, &quot;Arag&quot;)
colnames(carbcompletesitearag_min)&lt;-c(&quot;id&quot;, &quot;Arag&quot;)
colnames(highfreqsitearag_min)&lt;-c(&quot;id&quot;, &quot;Arag&quot;)
# substitute polygon id for monitoring site sea surface temerature of that polygon
polygonarag_min&lt;-subs(vorraster, sitearag_min, by=&quot;id&quot;, which=&quot;Arag&quot;, subsWithNA=FALSE)
carbcompletepolygonarag_min &lt;- subs(carbcompletevorraster, carbcompletesitearag_min, by=&quot;id&quot;, which=&quot;Arag&quot;, subsWithNA=FALSE)
highfreqpolygonarag_min &lt;- subs(highfreqvorraster, highfreqsitearag_min, by=&quot;id&quot;, which=&quot;Arag&quot;, subsWithNA=FALSE)</code></pre>
</div>
<div id="determine-semivariance-of-aragonite-discrepancy" class="section level4">
<h4>Determine semivariance of aragonite discrepancy</h4>
<p>We then used the empirical model outputs created using the continuous environmental layers to find the difference between the empirical model outputs at every location in the ocean and the empirical model outputs for the nearest monitoring asset. The result is an aragonite saturation state discrepancy value that describes how different acidification conditions are at any point on the West Coast as compared to these conditions at the nearest data collection location. In places where this value is high, a monitoring asset is not describing OA conditions well. In places where this value is low, a monitoring asset describes OA conditions very well. In the future, when aragonite saturation state models are available on a regional scale, outputs from such models could replace our empirical model outputs.</p>
<pre class="r"><code>#vij = (xi-xj)^2/2

discrepancy_1 = (arag_min)-(polygonarag_max)</code></pre>
<pre><code>## Warning in (arag_min) - (polygonarag_max): Raster objects have different
## extents. Result for their intersection is returned</code></pre>
<pre class="r"><code>discrepancy_1[discrepancy_1 &lt; 0] = 0
discrepancy_2 =(arag_max)-(polygonarag_min)</code></pre>
<pre><code>## Warning in (arag_max) - (polygonarag_min): Raster objects have different
## extents. Result for their intersection is returned</code></pre>
<pre class="r"><code>discrepancy_2[discrepancy_2 &lt; 0] = 0
discrepancy = mosaic(discrepancy_1, discrepancy_2, fun = min)


ccdiscrepancy_1 = (arag_min)-(carbcompletepolygonarag_max)</code></pre>
<pre><code>## Warning in (arag_min) - (carbcompletepolygonarag_max): Raster objects have
## different extents. Result for their intersection is returned</code></pre>
<pre class="r"><code>ccdiscrepancy_1[ccdiscrepancy_1 &lt; 0] = 0
ccdiscrepancy_2 = (arag_max)-(carbcompletepolygonarag_min)</code></pre>
<pre><code>## Warning in (arag_max) - (carbcompletepolygonarag_min): Raster objects have
## different extents. Result for their intersection is returned</code></pre>
<pre class="r"><code>ccdiscrepancy_2[ccdiscrepancy_2 &lt; 0] = 0
ccdiscrepancy = mosaic(ccdiscrepancy_1, ccdiscrepancy_2, fun = min)


hfdiscrepancy_1 = (arag_min)-(highfreqpolygonarag_max)</code></pre>
<pre><code>## Warning in (arag_min) - (highfreqpolygonarag_max): Raster objects have
## different extents. Result for their intersection is returned</code></pre>
<pre class="r"><code>hfdiscrepancy_1[hfdiscrepancy_1 &lt; 0] = 0
hfdiscrepancy_2 = (arag_max)-(highfreqpolygonarag_min)</code></pre>
<pre><code>## Warning in (arag_max) - (highfreqpolygonarag_min): Raster objects have
## different extents. Result for their intersection is returned</code></pre>
<pre class="r"><code>hfdiscrepancy_2[hfdiscrepancy_2 &lt; 0] = 0
hfdiscrepancy = mosaic(hfdiscrepancy_1, hfdiscrepancy_2, fun = min)



discrepancy &lt;- mask(discrepancy, poly_coast, inverse = TRUE) #Clip continuous raster
discrepancy &lt;- mask(discrepancy, estuaries, inverse = TRUE) #Clip continuous raster
discrepancy &lt;- mask(discrepancy, sf_puget, inverse = TRUE) #Clip continuous raster

ccdiscrepancy &lt;- mask(ccdiscrepancy, poly_coast, inverse = TRUE) #Clip continuous raster
ccdiscrepancy &lt;- mask(ccdiscrepancy, estuaries, inverse = TRUE) #Clip continuous raster
ccdiscrepancy &lt;- mask(ccdiscrepancy, sf_puget, inverse = TRUE) #Clip continuous raster

hfdiscrepancy &lt;- mask(hfdiscrepancy, poly_coast, inverse = TRUE) #Clip continuous raster
hfdiscrepancy &lt;- mask(hfdiscrepancy, estuaries, inverse = TRUE) #Clip continuous raster
hfdiscrepancy &lt;- mask(hfdiscrepancy, sf_puget, inverse = TRUE) #Clip continuous raster

plot(discrepancy)</code></pre>
<p><img src="gap_manuscript_files/figure-html/semivariance-1.png" width="672" /></p>
<pre class="r"><code>plot(ccdiscrepancy)</code></pre>
<p><img src="gap_manuscript_files/figure-html/semivariance-2.png" width="672" /></p>
<pre class="r"><code>plot(hfdiscrepancy)</code></pre>
<p><img src="gap_manuscript_files/figure-html/semivariance-3.png" width="672" /></p>
<pre class="r"><code>vij&lt;- (discrepancy)^2/2
carbcompletevij &lt;- (ccdiscrepancy)^2/2
highfreqvij &lt;- (hfdiscrepancy)^2/2</code></pre>
</div>
</div>
<div id="step-3.-geographic-and-oceanographic-distance" class="section level2">
<h2>Step 3. Geographic and oceanographic distance</h2>
<div id="oceanographic-distance" class="section level4">
<h4>Oceanographic distance</h4>
<p>The inverse of the linear relationship from the semi-variogram was applied to the semi-variance calculated above, yielding a map showing the “oceanographic distance” between each cell in our study region and the nearest monitoring asset. We define oceanographic distance as the effective distance between any location and the nearest monitoring asset, based on the similarity of oceanographic conditions that determine OA conditions between the two locations. A cell with high oceanographic distance has different acidification conditions than the nearest monitoring asset, and a cell with low oceanographic distance has similar acidification conditions to the nearest monitoring asset.</p>
<pre class="r"><code>#variogram does not saturate: develop an equation to describe relationship using square root function...

model &lt;- lm(aragvar@variogram[[&quot;gamma&quot;]] ~ 0 + I((aragvar@variogram[[&quot;distance&quot;]])))
summary(model)

summary(model)

xbar&lt;-aragvar@variogram[[&quot;distance&quot;]]
ybar&lt;-(xbar)*model$coefficients[1]

ggplot()+
  geom_point(aes(aragvar@variogram[[&quot;distance&quot;]], aragvar@variogram[[&quot;gamma&quot;]]), color = &quot;red&quot;)+
  geom_point(aes(xbar, ybar), color = &quot;blue&quot;)+
  theme_bw()+
  ggtitle(&#39;Variogram (red) and predictive model (blue)&#39;)+
  xlab(&#39;Distance Between Points (m)&#39;)+
  ylab(&#39;Semivariance of Aragonite Discrepancy&#39;)+
  theme(text = element_text(size = 10, family=&quot;serif&quot;))</code></pre>
<p><img src="gap_manuscript_files/figure-html/oceanographic%20distance-1.png" width="672" /></p>
<pre class="r"><code>oceanographicdistance = (vij/(4.303e-08  ))/(1000)
carbcompleteoceanographicdistance = (carbcompletevij/(4.303e-08 ))/(1000)
highfreqoceanographicdistance = (highfreqvij/(4.303e-08))/(1000)

plot(oceanographicdistance)</code></pre>
<p><img src="gap_manuscript_files/figure-html/oceanographic%20distance-2.png" width="672" /></p>
<pre class="r"><code>plot(carbcompleteoceanographicdistance)</code></pre>
<p><img src="gap_manuscript_files/figure-html/oceanographic%20distance-3.png" width="672" /></p>
<pre class="r"><code>plot(highfreqoceanographicdistance)</code></pre>
<p><img src="gap_manuscript_files/figure-html/oceanographic%20distance-4.png" width="672" /></p>
<pre class="r"><code>od_clipped &lt;- mask(oceanographicdistance, poly_coast, inverse = TRUE) #Clip continuous raster
od_clipped &lt;- mask(od_clipped, estuaries, inverse = TRUE) #Clip continuous raster
od_clipped &lt;- mask(od_clipped, sf_puget, inverse = TRUE) #Clip continuous raster

plot(od_clipped)</code></pre>
<p><img src="gap_manuscript_files/figure-html/oceanographic%20distance-5.png" width="672" /></p>
</div>
<div id="geographic-distance" class="section level4">
<h4>Geographic distance</h4>
<p>Determine geographic distance from the nearest monitoring point</p>
<pre class="r"><code>distance&lt;-distanceFromPoints(oceanographicdistance, inventorycoords)/1000

distance_clipped &lt;- mask(distance, poly_coast, inverse = TRUE) #Clip continuous raster
distance_clipped &lt;- mask(distance_clipped, estuaries, inverse = TRUE) #Clip continuous raster
distance_clipped &lt;- mask(distance_clipped, sf_puget, inverse = TRUE) #Clip continuous raster

plot(distance_clipped)</code></pre>
<p><img src="gap_manuscript_files/figure-html/geographic%20distance-1.png" width="672" /></p>
<pre class="r"><code>carbcompletedistance&lt;-distanceFromPoints(carbcompleteoceanographicdistance, carbcompletecoords)/1000

carbcompletedistance_clipped &lt;- mask(carbcompletedistance, poly_coast, inverse = TRUE) #Clip continuous raster
carbcompletedistance_clipped &lt;- mask(carbcompletedistance_clipped, estuaries, inverse = TRUE) #Clip continuous raster
carbcompletedistance_clipped &lt;- mask(carbcompletedistance_clipped, sf_puget, inverse = TRUE) #Clip continuous raster

plot(carbcompletedistance_clipped)</code></pre>
<p><img src="gap_manuscript_files/figure-html/geographic%20distance-2.png" width="672" /></p>
<pre class="r"><code>highfreqdistance&lt;-distanceFromPoints(highfreqoceanographicdistance, highfreqcoords)/1000

highfreqdistance_clipped &lt;- mask(highfreqdistance, poly_coast, inverse = TRUE) #Clip continuous raster
highfreqdistance_clipped &lt;- mask(highfreqdistance_clipped, estuaries, inverse = TRUE) #Clip continuous raster
highfreqdistance_clipped &lt;- mask(highfreqdistance_clipped, sf_puget, inverse = TRUE) #Clip continuous raster

plot(highfreqdistance_clipped)</code></pre>
<p><img src="gap_manuscript_files/figure-html/geographic%20distance-3.png" width="672" /></p>
</div>
</div>
<div id="step-4.-find-gaps" class="section level2">
<h2>Step 4. Find Gaps</h2>
<div id="combine-ingredients" class="section level4">
<h4>Combine ingredients</h4>
<p>We used a Euclidean distance approach to combine geographic distance and oceanographic distance into a single “gap” layer. Thus, a gap in the network is a place where oceanographic conditions are different from conditions at the nearest data collection location, a place that is geographically far from the nearest data collection, or a place with both of these characteristics. When combining these two, we weighted the oceanographic distance term by multiplying it by the unitless ratio of the maximum value of geographic distance and the maximum value of the oceanographic distance.</p>
<pre class="r"><code>#calculate gaps

weight = maxValue(od_clipped)/maxValue(distance_clipped)

gap&lt;-(sqrt((weight*distance_clipped)^2+(oceanographicdistance)^2))

carbcompletegap&lt;-(sqrt((weight*carbcompletedistance_clipped)^2+(carbcompleteoceanographicdistance)^2))

carbcompletegap&lt;-(sqrt((carbcompletedistance_clipped)^2+(carbcompleteoceanographicdistance)^2))

highfreqgap&lt;-(sqrt((weight*highfreqdistance_clipped)^2+(highfreqoceanographicdistance)^2))

gap &lt;- crop(gap, ext_study)
carbcompletegap &lt;- crop(carbcompletegap, ext_study)
highfreqgap &lt;- crop(highfreqgap, ext_study)

plot(gap)</code></pre>
<p><img src="gap_manuscript_files/figure-html/find%20gaps-1.png" width="672" /></p>
<pre class="r"><code>plot(carbcompletegap)</code></pre>
<p><img src="gap_manuscript_files/figure-html/find%20gaps-2.png" width="672" /></p>
<pre class="r"><code>plot(highfreqgap)</code></pre>
<p><img src="gap_manuscript_files/figure-html/find%20gaps-3.png" width="672" /></p>
</div>
<div id="map-gaps" class="section level4">
<h4>Map Gaps</h4>
<p><img src="gap_manuscript_files/figure-html/map%20gaps-1.png" width="25%" /><img src="gap_manuscript_files/figure-html/map%20gaps-2.png" width="25%" /><img src="gap_manuscript_files/figure-html/map%20gaps-3.png" width="25%" /></p>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
